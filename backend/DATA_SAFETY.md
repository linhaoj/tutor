# 数据安全保障文档

## 📋 概述

本系统是教育培训管理平台，涉及**学生缴费**和**课时管理**等关键业务，数据准确性至关重要。我们实现了**生产级数据库事务安全系统**，确保每一次数据修改都是正确的。

---

## 🛡️ 核心安全机制

### 1. 事务自动回滚

**问题**：如果操作中途出错，数据库可能处于不一致状态。

**解决方案**：所有写操作使用 `@safe_transaction` 装饰器，失败时自动回滚。

```python
@safe_transaction("扣减学生课时")
async def deduct_student_hours(...):
    # 步骤1: 检查学生是否存在
    # 步骤2: 检查课时是否充足
    # 步骤3: 扣减课时
    # 步骤4: 更新时间戳

    # 如果任何步骤失败，所有更改自动回滚
    # 数据库状态保持不变
```

**保障效果**：
- ✅ 操作全部成功 → 数据保存
- ❌ 任何步骤失败 → 数据回滚到操作前状态

---

### 2. 业务规则强制验证

**关键业务规则**：

#### 课时管理规则
```python
# 规则1: 课时不能为负数
validate_business_rule(
    hours > 0,
    "扣减课时必须大于0"
)

# 规则2: 单次扣减不超过10小时（防止误操作）
validate_business_rule(
    hours <= 10,
    "单次扣减课时不能超过10小时 (防止误操作)"
)

# 规则3: 余额充足
validate_business_rule(
    student.remaining_hours >= hours,
    f"剩余课时不足: 当前{student.remaining_hours}h，需要{hours}h"
)
```

**实际案例**：

| 操作 | 规则检查 | 结果 |
|------|---------|------|
| 扣减1.5小时（余额10h） | ✅ 全部通过 | 成功扣减，余额 8.5h |
| 扣减15小时 | ❌ 超过10h限制 | 拒绝操作，提示误操作 |
| 扣减5小时（余额3h） | ❌ 余额不足 | 拒绝操作，余额不变 |
| 扣减-2小时 | ❌ 负数无效 | 拒绝操作 |

---

### 3. 数据完整性保护

**数据库约束**：

```python
# 唯一性约束
- 用户名必须唯一
- 邮箱必须唯一（学生/用户）

# 外键约束
- 学生必须关联到有效的教师
- 课程必须关联到有效的学生
- 进度必须关联到有效的学生

# 非空约束
- 学生必须有姓名
- 用户必须有密码哈希
- 课程必须有日期和时间
```

**自动处理**：

```python
try:
    # 创建重复邮箱的学生
    new_student = Student(email="existing@example.com")
    db.add(new_student)
    db.commit()
except IntegrityError:
    # 自动回滚
    # 返回友好提示："邮箱已被使用"
```

---

### 4. 详细的操作日志

**每次关键操作都会记录**：

#### 课时扣减日志示例
```
2025-10-14 10:15:30 | INFO | 课时扣减成功: 学生=张三, 扣减=1.0h, 10.0h → 9.0h, 操作人=teacher1
```

#### 失败操作日志示例
```
2025-10-14 10:20:15 | WARNING | 业务规则验证失败: 剩余课时不足: 当前0.5h，需要1.0h
2025-10-14 10:20:15 | ERROR | 扣减学生课时失败 [数据库错误]: 事务已回滚
```

**日志包含信息**：
- ⏰ 操作时间（精确到秒）
- 👤 操作人（教师/管理员）
- 📊 数据变化（前后对比）
- ❌ 失败原因（详细错误）

---

## 🔒 受保护的操作列表

### 高风险操作（涉及金钱/课时）

| 操作 | 保护机制 | 验证规则 |
|------|---------|---------|
| **扣减课时** | 事务回滚 + 业务规则 | 余额充足、金额有效、防误操作 |
| **创建学生** | 事务回滚 + 唯一性 | 邮箱唯一、课时非负 |
| **更新课时** | 事务回滚 + 业务规则 | 课时非负 |
| **删除学生** | 事务回滚 + 权限检查 | 只能删除自己的学生 |

### 中等风险操作（账号/课程）

| 操作 | 保护机制 | 验证规则 |
|------|---------|---------|
| **创建用户** | 事务回滚 + 唯一性 | 用户名唯一、邮箱唯一 |
| **创建课程** | 事务回滚 + 外键 | 学生必须存在 |
| **保存进度** | 事务回滚 | 学生必须存在 |

### 低风险操作（查询）

| 操作 | 保护机制 |
|------|---------|
| **查询学生列表** | 权限隔离（只能看自己的学生） |
| **查询课程列表** | 权限隔离（只能看自己的课程） |
| **查询学习进度** | 权限隔离 |

---

## 🎯 并发安全

**问题场景**：两个教师同时为同一个学生扣减课时

```
时间线：
10:00:00 - 教师A读取学生课时：10.0h
10:00:00 - 教师B读取学生课时：10.0h
10:00:01 - 教师A扣减1.0h → 写入 9.0h ✅
10:00:02 - 教师B扣减1.0h → 写入 9.0h ❌ (错误！应该是8.0h)
```

**解决方案**：

1. **数据库行级锁**（SQLAlchemy默认）
   - 第一个事务锁定学生记录
   - 第二个事务等待第一个完成
   - 保证顺序执行

2. **事务隔离级别**
   - SQLite默认使用 SERIALIZABLE
   - 保证并发操作的安全性

**实际效果**：
```
10:00:00 - 教师A锁定学生记录，读取10.0h
10:00:00 - 教师B尝试锁定 → 等待中...
10:00:01 - 教师A扣减1.0h → 写入9.0h → 释放锁 ✅
10:00:01 - 教师B获得锁，读取9.0h
10:00:02 - 教师B扣减1.0h → 写入8.0h ✅
```

---

## 📊 错误分级处理

### Level 1: 业务规则错误（用户可修正）

**HTTP 400 Bad Request**

```json
{
  "detail": "剩余课时不足: 当前0.5h，需要1.0h"
}
```

**常见原因**：
- 课时不足
- 邮箱重复
- 数据格式错误

**处理方式**：
- ✅ 不影响数据库
- ✅ 用户看到明确提示
- ✅ 记录警告日志

---

### Level 2: 数据完整性错误（数据冲突）

**HTTP 400 Bad Request**

```json
{
  "detail": "数据重复: 该记录已存在"
}
```

**常见原因**：
- 唯一性约束冲突
- 外键约束冲突

**处理方式**：
- ✅ 自动回滚事务
- ✅ 记录错误日志
- ✅ 友好提示用户

---

### Level 3: 数据库错误（系统故障）

**HTTP 500 Internal Server Error**

```json
{
  "detail": "数据库操作失败，所有更改已回滚"
}
```

**常见原因**：
- 数据库连接失败
- 磁盘空间不足
- SQL语法错误

**处理方式**：
- ✅ 立即回滚所有更改
- ✅ 记录详细错误日志
- ✅ 通知用户稍后重试

---

## 🧪 测试场景

### 场景1: 课时扣减成功

```python
# 前置条件
学生"张三"剩余课时: 10.0h

# 执行操作
POST /api/students/1/deduct-hours
Body: {"hours": 1.5}

# 预期结果
✅ HTTP 200
✅ 返回: {"remaining_hours": 8.5, "deducted_hours": 1.5}
✅ 数据库: 学生课时 = 8.5h
✅ 日志: "课时扣减成功: 学生=张三, 扣减=1.5h, 10.0h → 8.5h"
```

---

### 场景2: 课时不足（事务回滚）

```python
# 前置条件
学生"李四"剩余课时: 0.5h

# 执行操作
POST /api/students/2/deduct-hours
Body: {"hours": 1.0}

# 预期结果
❌ HTTP 400
❌ 返回: {"detail": "剩余课时不足: 当前0.5h，需要1.0h"}
✅ 数据库: 学生课时仍为 0.5h (未改变)
✅ 日志: "业务规则验证失败: 剩余课时不足..."
```

---

### 场景3: 并发扣减（顺序执行）

```python
# 前置条件
学生"王五"剩余课时: 10.0h

# 并发操作
时间 10:00:00 - 教师A: 扣减1.0h
时间 10:00:00 - 教师B: 扣减2.0h

# 预期结果（顺序执行）
✅ 教师A完成: 10.0h → 9.0h
✅ 教师B等待后完成: 9.0h → 7.0h
✅ 最终课时: 7.0h (正确！)
❌ 不会出现: 8.0h (错误情况)
```

---

### 场景4: 中途失败回滚

```python
# 模拟场景：创建学生时数据库断开

# 执行操作
POST /api/students
Body: {"name": "赵六", "email": "test@example.com", "remaining_hours": 10}

# 执行步骤
1. ✅ 验证邮箱唯一性
2. ✅ 创建学生对象
3. ✅ 添加到数据库
4. ❌ 提交事务时数据库断开

# 预期结果
❌ HTTP 500
❌ 返回: {"detail": "数据库操作失败，所有更改已回滚"}
✅ 数据库: 学生未创建（完全回滚）
✅ 日志: "创建学生失败 [数据库错误]: 事务已回滚"
```

---

## 🚨 应急预案

### 数据异常发现

如果发现数据异常：

1. **查看日志**
   ```bash
   # 查看今天的所有日志
   cat backend/logs/app_2025-10-14.log

   # 查看错误日志
   cat backend/logs/error_2025-10-14.log

   # 搜索特定学生的操作
   grep "学生=张三" backend/logs/app_*.log
   ```

2. **日志包含的追溯信息**
   - 操作时间（精确到秒）
   - 操作人（教师/管理员ID）
   - 数据变化（前值 → 后值）
   - 失败原因

3. **恢复策略**
   - 所有操作都有日志记录
   - 可以追溯任何数据变化
   - 必要时可以手动回滚

---

### 备份策略

**数据库文件**：`backend/english_tutor.db`

**建议备份频率**：
- 每日自动备份（凌晨3点）
- 重大操作前手动备份

**备份命令**：
```bash
# 手动备份
cp backend/english_tutor.db backend/backups/english_tutor_$(date +%Y%m%d_%H%M%S).db

# 查看备份
ls -lh backend/backups/
```

---

## ✅ 安全保障总结

| 保障措施 | 实现状态 | 覆盖范围 |
|---------|---------|---------|
| ✅ 事务自动回滚 | 已实现 | 所有写操作 |
| ✅ 业务规则验证 | 已实现 | 课时/用户/学生 |
| ✅ 数据完整性约束 | 已实现 | 数据库级别 |
| ✅ 并发安全 | 已实现 | SQLite行锁 |
| ✅ 详细日志记录 | 已实现 | 所有操作 |
| ✅ 错误友好提示 | 已实现 | 所有API |
| ⚠️ 自动备份 | 待配置 | 需要cron任务 |

---

## 🎓 给开发者的建议

### 添加新功能时

1. **所有写操作都加事务保护**
   ```python
   @router.post("/new-operation")
   @safe_transaction("操作描述")  # 必须加这个！
   async def new_operation(...):
       ...
   ```

2. **重要的业务规则要验证**
   ```python
   validate_business_rule(
       condition,
       "友好的错误提示"
   )
   ```

3. **关键操作记录日志**
   ```python
   logger.info(f"操作成功: 详细信息...")
   logger.warning(f"操作失败: 原因...")
   ```

---

## 📞 技术支持

如有疑问，请查看：
- 代码实现：`backend/app/database_safety.py`
- 使用示例：`backend/app/routes/students_api.py`
- 日志文件：`backend/logs/`

---

**最后更新**: 2025-10-14
**文档版本**: 1.0
**系统状态**: ✅ 生产就绪
